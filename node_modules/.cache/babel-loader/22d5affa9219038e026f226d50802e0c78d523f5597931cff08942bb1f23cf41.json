{"ast":null,"code":"import { buildYouTubeUrl, YOUTUBE_ENDPOINTS } from '../config/youtube';\nclass YouTubeService {\n  constructor() {\n    this.config = void 0;\n    this.lastApiCall = 0;\n    this.apiCallCount = 0;\n    this.MAX_DAILY_CALLS = 4;\n    // Maximum 4 calls per day (very conservative)\n    this.MIN_CALL_INTERVAL = 21600000;\n    // 6 hours between calls (4 per day max)\n    this.cachedData = {\n      lastCached: 0\n    };\n    // Load saved configuration from localStorage\n    const savedConfig = localStorage.getItem('youtubeConfig');\n    console.log('Loading YouTube config from localStorage:', savedConfig);\n    if (savedConfig) {\n      const parsed = JSON.parse(savedConfig);\n      this.config = {\n        channelId: parsed.channelId || '',\n        apiKey: parsed.apiKey || '',\n        channelName: parsed.channelName || '',\n        channelUrl: parsed.channelUrl || ''\n      };\n      console.log('Loaded config:', this.config);\n    } else {\n      this.config = {\n        channelId: '',\n        apiKey: '',\n        channelName: '',\n        channelUrl: ''\n      };\n      console.log('No saved config, using defaults');\n    }\n\n    // Load API call tracking from localStorage\n    this.loadApiCallTracking();\n\n    // Load cached data from localStorage\n    this.loadCachedData();\n  }\n  loadApiCallTracking() {\n    const today = new Date().toDateString();\n    const savedTracking = localStorage.getItem('youtubeApiTracking');\n    if (savedTracking) {\n      const tracking = JSON.parse(savedTracking);\n      if (tracking.date === today) {\n        this.apiCallCount = tracking.count || 0;\n        this.lastApiCall = tracking.lastCall || 0;\n      } else {\n        // Reset for new day\n        this.apiCallCount = 0;\n        this.lastApiCall = 0;\n      }\n    }\n  }\n  saveApiCallTracking() {\n    const tracking = {\n      date: new Date().toDateString(),\n      count: this.apiCallCount,\n      lastCall: this.lastApiCall\n    };\n    localStorage.setItem('youtubeApiTracking', JSON.stringify(tracking));\n  }\n  loadCachedData() {\n    const savedCachedData = localStorage.getItem('youtubeCachedData');\n    if (savedCachedData) {\n      this.cachedData = JSON.parse(savedCachedData);\n      console.log('Loaded cached data:', this.cachedData);\n    } else {\n      console.log('No cached data found in localStorage');\n    }\n  }\n  saveCachedData() {\n    localStorage.setItem('youtubeCachedData', JSON.stringify(this.cachedData));\n  }\n  canMakeApiCall() {\n    const now = Date.now();\n\n    // Check if we've exceeded daily limit\n    if (this.apiCallCount >= this.MAX_DAILY_CALLS) {\n      console.log('Daily API call limit reached');\n      return false;\n    }\n\n    // Check if enough time has passed since last call\n    if (now - this.lastApiCall < this.MIN_CALL_INTERVAL) {\n      console.log('API call rate limit: waiting for cooldown');\n      return false;\n    }\n    return true;\n  }\n\n  // Check if we've actually hit the YouTube API quota (403 errors)\n  async checkActualApiQuota() {\n    if (!this.config.apiKey || !this.config.channelId) {\n      return true; // No config means no quota check needed\n    }\n\n    // If we have cached data from today, assume API is working\n    const today = new Date().toDateString();\n    const cachedDate = new Date(this.cachedData.lastCached).toDateString();\n    if (this.cachedData.channelStats && cachedDate === today) {\n      console.log('Using cached data from today, assuming API is available');\n      return true;\n    }\n\n    // Only check actual quota if we haven't made a call recently\n    const timeSinceLastCall = Date.now() - this.lastApiCall;\n    if (timeSinceLastCall < 300000) {\n      // 5 minutes\n      console.log('Recent API call made, skipping quota check');\n      return true;\n    }\n    try {\n      const url = buildYouTubeUrl(YOUTUBE_ENDPOINTS.channel, {\n        part: 'statistics,snippet',\n        id: this.config.channelId\n      }, this.config.apiKey);\n      const response = await fetch(url);\n      console.log('Quota check response status:', response.status);\n      if (response.status === 403) {\n        console.log('YouTube API quota actually exceeded');\n        return false; // Quota exceeded\n      }\n      return true; // API is available\n    } catch (error) {\n      console.log('Error checking API quota:', error);\n      return false; // Assume quota exceeded on error\n    }\n  }\n  recordApiCall() {\n    this.apiCallCount++;\n    this.lastApiCall = Date.now();\n    this.saveApiCallTracking();\n    console.log(`API call recorded. Daily count: ${this.apiCallCount}/${this.MAX_DAILY_CALLS}`);\n  }\n  updateConfig(newConfig) {\n    this.config = newConfig;\n    localStorage.setItem('youtubeConfig', JSON.stringify(newConfig));\n  }\n  getConfig() {\n    return this.config;\n  }\n\n  // Debug method to check localStorage\n  debugCachedData() {\n    const savedCachedData = localStorage.getItem('youtubeCachedData');\n    const savedConfig = localStorage.getItem('youtubeConfig');\n    const savedTracking = localStorage.getItem('youtubeApiTracking');\n    console.log('=== DEBUG CACHED DATA ===');\n    console.log('youtubeCachedData:', savedCachedData);\n    console.log('youtubeConfig:', savedConfig);\n    console.log('youtubeApiTracking:', savedTracking);\n    console.log('Current cachedData object:', this.cachedData);\n    console.log('========================');\n    return {\n      cachedData: savedCachedData ? JSON.parse(savedCachedData) : null,\n      config: savedConfig ? JSON.parse(savedConfig) : null,\n      tracking: savedTracking ? JSON.parse(savedTracking) : null,\n      currentCachedData: this.cachedData\n    };\n  }\n\n  // Method to manually cache demo data as real data (for testing)\n  cacheDemoDataAsReal() {\n    const demoChannelStats = {\n      subscriberCount: 12400,\n      videoCount: 89,\n      viewCount: 1800000,\n      channelName: this.config.channelName || 'Maggo',\n      channelUrl: this.config.channelUrl || 'https://www.youtube.com/@maggo',\n      channelId: this.config.channelId || 'UCZggs3Q7sC5QQZGeQYJd5pA'\n    };\n    const demoVideos = [{\n      id: 'demo-video-1',\n      title: 'Sample Video Title 1',\n      publishedAt: '2024-01-15T10:00:00Z',\n      viewCount: 15000,\n      likeCount: 1200,\n      commentCount: 89,\n      thumbnail: 'https://via.placeholder.com/320x180',\n      duration: 'PT10M30S'\n    }, {\n      id: 'demo-video-2',\n      title: 'Sample Video Title 2',\n      publishedAt: '2024-01-10T14:30:00Z',\n      viewCount: 22000,\n      likeCount: 1800,\n      commentCount: 156,\n      thumbnail: 'https://via.placeholder.com/320x180',\n      duration: 'PT15M45S'\n    }];\n    this.cachedData.channelStats = demoChannelStats;\n    this.cachedData.recentVideos = demoVideos;\n    this.cachedData.lastCached = Date.now();\n    this.saveCachedData();\n    console.log('Manually cached demo data as real data:', this.cachedData);\n    return this.cachedData;\n  }\n  async getApiCallStatus() {\n    // Check if we have valid config\n    const hasValidConfig = this.config.apiKey && this.config.channelId;\n\n    // If no valid config, show as unlimited since we're using demo data\n    if (!hasValidConfig) {\n      return {\n        dailyCalls: 0,\n        maxCalls: this.MAX_DAILY_CALLS,\n        remainingCalls: this.MAX_DAILY_CALLS,\n        lastCall: this.lastApiCall,\n        canMakeCall: true,\n        usingDemoData: true,\n        reason: 'No API configuration',\n        showCallCount: false,\n        actualQuotaExceeded: false\n      };\n    }\n\n    // Check if we're actually hitting quota limits\n    const isQuotaExceeded = this.apiCallCount >= this.MAX_DAILY_CALLS;\n    const isRateLimited = Date.now() - this.lastApiCall < this.MIN_CALL_INTERVAL;\n    const hasCachedData = this.cachedData.channelStats && this.cachedData.recentVideos;\n\n    // Check actual YouTube API quota status\n    const actualQuotaAvailable = await this.checkActualApiQuota();\n    const actualQuotaExceeded = !actualQuotaAvailable;\n\n    // Calculate time until next available call\n    const timeUntilNextCall = this.lastApiCall + this.MIN_CALL_INTERVAL - Date.now();\n    const minutesUntilNext = Math.ceil(timeUntilNextCall / 60000);\n\n    // Determine the actual status\n    let canMakeCall = true;\n    let showCallCount = true;\n    if (actualQuotaExceeded) {\n      canMakeCall = false;\n      showCallCount = false;\n    } else if (isQuotaExceeded) {\n      canMakeCall = false;\n      showCallCount = false;\n    } else if (isRateLimited) {\n      canMakeCall = false;\n      showCallCount = false;\n    }\n    return {\n      dailyCalls: this.apiCallCount,\n      maxCalls: this.MAX_DAILY_CALLS,\n      remainingCalls: Math.max(0, this.MAX_DAILY_CALLS - this.apiCallCount),\n      lastCall: this.lastApiCall,\n      canMakeCall,\n      usingCachedData: !canMakeCall && hasCachedData,\n      usingDemoData: !canMakeCall && !hasCachedData,\n      reason: isQuotaExceeded ? 'Daily quota exceeded - wait 24 hours (4 calls max)' : isRateLimited ? `Rate limited - wait ${minutesUntilNext} minutes (6h cooldown)` : 'Ready',\n      showCallCount,\n      timeUntilNext: timeUntilNextCall,\n      actualQuotaExceeded\n    };\n  }\n  async fetchFromAPI(url) {\n    console.log('Making API call to:', url);\n    const response = await fetch(url);\n    console.log('API response status:', response.status);\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('API Error response:', errorText);\n      if (response.status === 403) {\n        throw new Error('API quota exceeded or invalid API key');\n      } else if (response.status === 400) {\n        throw new Error('Invalid request - check channel ID');\n      } else {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n    }\n    const data = await response.json();\n    console.log('API response data:', data);\n    return data;\n  }\n  async getChannelStats() {\n    console.log('getChannelStats called with config:', this.config);\n    console.log('Current cached data:', this.cachedData);\n\n    // If no API key or channel ID, return mock data\n    if (!this.config.apiKey || !this.config.channelId) {\n      console.log('No API key or channel ID, returning mock data');\n      return {\n        subscriberCount: 12400,\n        videoCount: 89,\n        viewCount: 1800000,\n        channelName: this.config.channelName || 'Demo Channel',\n        channelUrl: this.config.channelUrl || 'https://www.youtube.com/@demo',\n        channelId: this.config.channelId || 'demo-channel-id'\n      };\n    }\n\n    // Check if we have cached data from today first\n    const today = new Date().toDateString();\n    const cachedDate = this.cachedData.lastCached ? new Date(this.cachedData.lastCached).toDateString() : null;\n    console.log('Today:', today, 'Cached date:', cachedDate);\n    if (this.cachedData.channelStats && cachedDate === today) {\n      console.log('Returning cached channel stats from today');\n      return this.cachedData.channelStats;\n    }\n\n    // Check if we can make API call\n    if (!this.canMakeApiCall()) {\n      console.log('API call limit reached, checking cached data');\n\n      // Return cached data if available (even from previous days)\n      if (this.cachedData.channelStats) {\n        console.log('Returning cached channel stats from previous days');\n        return this.cachedData.channelStats;\n      }\n\n      // Fall back to mock data if no cache\n      console.log('No cached data, returning mock data');\n      return {\n        subscriberCount: 12400,\n        videoCount: 89,\n        viewCount: 1800000,\n        channelName: this.config.channelName || 'Demo Channel',\n        channelUrl: this.config.channelUrl || 'https://www.youtube.com/@demo',\n        channelId: this.config.channelId || 'demo-channel-id'\n      };\n    }\n\n    // Try to make API call and cache the result\n    try {\n      const url = buildYouTubeUrl(YOUTUBE_ENDPOINTS.channel, {\n        part: 'statistics,snippet',\n        id: this.config.channelId\n      }, this.config.apiKey);\n      const data = await this.fetchFromAPI(url);\n      this.recordApiCall();\n      if (data.items && data.items.length > 0) {\n        const channel = data.items[0];\n        const channelStats = {\n          subscriberCount: parseInt(channel.statistics.subscriberCount || '0'),\n          videoCount: parseInt(channel.statistics.videoCount || '0'),\n          viewCount: parseInt(channel.statistics.viewCount || '0'),\n          channelName: channel.snippet.title,\n          channelUrl: `https://www.youtube.com/channel/${channel.id}`,\n          channelId: channel.id\n        };\n\n        // Cache the successful API response\n        this.cachedData.channelStats = channelStats;\n        this.cachedData.lastCached = Date.now();\n        this.saveCachedData();\n        console.log('Successfully cached channel stats:', channelStats);\n        return channelStats;\n      }\n      throw new Error('Channel not found');\n    } catch (error) {\n      console.error('Error in getChannelStats:', error);\n\n      // If we have any cached data, return it even if it's old\n      if (this.cachedData.channelStats) {\n        console.log('API failed, returning cached data');\n        return this.cachedData.channelStats;\n      }\n\n      // Return mock data if API fails and no cache exists\n      console.log('API failed and no cache, returning mock data');\n      return {\n        subscriberCount: 12400,\n        videoCount: 89,\n        viewCount: 1800000,\n        channelName: this.config.channelName || 'Demo Channel',\n        channelUrl: this.config.channelUrl || 'https://www.youtube.com/@demo',\n        channelId: this.config.channelId || 'demo-channel-id'\n      };\n    }\n  }\n  async getRecentVideos(limit = 10) {\n    // If no API key or channel ID, return mock data\n    if (!this.config.apiKey || !this.config.channelId) {\n      return [{\n        id: 'mock-video-1',\n        title: 'Sample Video Title 1',\n        publishedAt: '2024-01-15T10:00:00Z',\n        viewCount: 15000,\n        likeCount: 1200,\n        commentCount: 89,\n        thumbnail: 'https://via.placeholder.com/320x180',\n        duration: 'PT10M30S'\n      }, {\n        id: 'mock-video-2',\n        title: 'Sample Video Title 2',\n        publishedAt: '2024-01-10T14:30:00Z',\n        viewCount: 22000,\n        likeCount: 1800,\n        commentCount: 156,\n        thumbnail: 'https://via.placeholder.com/320x180',\n        duration: 'PT15M45S'\n      }];\n    }\n\n    // Check if we have cached data from today first\n    const today = new Date().toDateString();\n    const cachedDate = new Date(this.cachedData.lastCached).toDateString();\n    if (this.cachedData.recentVideos && cachedDate === today) {\n      console.log('Returning cached videos from today');\n      return this.cachedData.recentVideos;\n    }\n\n    // Check if we can make API call\n    if (!this.canMakeApiCall()) {\n      console.log('API call limit reached, checking cached videos');\n\n      // Return cached data if available (even from previous days)\n      if (this.cachedData.recentVideos) {\n        console.log('Returning cached videos');\n        return this.cachedData.recentVideos;\n      }\n\n      // Fall back to mock data if no cache\n      console.log('No cached videos, returning mock data');\n      return [{\n        id: 'mock-video-1',\n        title: 'Sample Video Title 1',\n        publishedAt: '2024-01-15T10:00:00Z',\n        viewCount: 15000,\n        likeCount: 1200,\n        commentCount: 89,\n        thumbnail: 'https://via.placeholder.com/320x180',\n        duration: 'PT10M30S'\n      }, {\n        id: 'mock-video-2',\n        title: 'Sample Video Title 2',\n        publishedAt: '2024-01-10T14:30:00Z',\n        viewCount: 22000,\n        likeCount: 1800,\n        commentCount: 156,\n        thumbnail: 'https://via.placeholder.com/320x180',\n        duration: 'PT15M45S'\n      }];\n    }\n    try {\n      // Make real API call\n      const url = buildYouTubeUrl(YOUTUBE_ENDPOINTS.videos, {\n        part: 'snippet',\n        channelId: this.config.channelId,\n        order: 'date',\n        maxResults: limit.toString(),\n        type: 'video'\n      }, this.config.apiKey);\n      const data = await this.fetchFromAPI(url);\n      this.recordApiCall();\n      if (data.items) {\n        const videoIds = data.items.map(item => item.id.videoId).join(',');\n\n        // Check if we can make another API call for video stats\n        if (!this.canMakeApiCall()) {\n          console.log('API call limit reached, returning videos without detailed stats');\n          return data.items.map(item => ({\n            id: item.id.videoId,\n            title: item.snippet.title,\n            publishedAt: item.snippet.publishedAt,\n            viewCount: 0,\n            likeCount: 0,\n            commentCount: 0,\n            thumbnail: item.snippet.thumbnails.medium.url,\n            duration: 'PT0S'\n          }));\n        }\n\n        // Get detailed video statistics\n        const statsUrl = buildYouTubeUrl(YOUTUBE_ENDPOINTS.videoStats, {\n          part: 'statistics,contentDetails',\n          id: videoIds\n        }, this.config.apiKey);\n        const statsData = await this.fetchFromAPI(statsUrl);\n        this.recordApiCall();\n        const statsMap = new Map();\n        if (statsData.items) {\n          statsData.items.forEach(item => {\n            statsMap.set(item.id, {\n              viewCount: parseInt(item.statistics.viewCount || '0'),\n              likeCount: parseInt(item.statistics.likeCount || '0'),\n              commentCount: parseInt(item.statistics.commentCount || '0'),\n              duration: item.contentDetails.duration\n            });\n          });\n        }\n        const videos = data.items.map(item => {\n          const stats = statsMap.get(item.id.videoId) || {\n            viewCount: 0,\n            likeCount: 0,\n            commentCount: 0,\n            duration: 'PT0S'\n          };\n          return {\n            id: item.id.videoId,\n            title: item.snippet.title,\n            publishedAt: item.snippet.publishedAt,\n            viewCount: stats.viewCount,\n            likeCount: stats.likeCount,\n            commentCount: stats.commentCount,\n            thumbnail: item.snippet.thumbnails.medium.url,\n            duration: stats.duration\n          };\n        });\n\n        // Cache the successful API response\n        this.cachedData.recentVideos = videos;\n        this.cachedData.lastCached = Date.now();\n        this.saveCachedData();\n        return videos;\n      }\n      return [];\n    } catch (error) {\n      console.error('Error in getRecentVideos:', error);\n\n      // Return mock data if API fails\n      return [{\n        id: 'mock-video-1',\n        title: 'Sample Video Title 1',\n        publishedAt: '2024-01-15T10:00:00Z',\n        viewCount: 15000,\n        likeCount: 1200,\n        commentCount: 89,\n        thumbnail: 'https://via.placeholder.com/320x180',\n        duration: 'PT10M30S'\n      }, {\n        id: 'mock-video-2',\n        title: 'Sample Video Title 2',\n        publishedAt: '2024-01-10T14:30:00Z',\n        viewCount: 22000,\n        likeCount: 1800,\n        commentCount: 156,\n        thumbnail: 'https://via.placeholder.com/320x180',\n        duration: 'PT15M45S'\n      }];\n    }\n  }\n  async getAnalytics() {\n    const [channelStats, recentVideos] = await Promise.all([this.getChannelStats(), this.getRecentVideos()]);\n\n    // Generate monthly data based on actual channel stats\n    const currentSubscribers = channelStats.subscriberCount;\n    const currentViews = channelStats.viewCount;\n\n    // Get current date and generate last 6 months\n    const now = new Date();\n    const months = [];\n    for (let i = 5; i >= 0; i--) {\n      const date = new Date(now.getFullYear(), now.getMonth() - i, 1);\n      months.push(date.toLocaleDateString('en-US', {\n        month: 'short'\n      }));\n    }\n\n    // Calculate progression factors for realistic growth\n    const progressionFactors = [0.7, 0.8, 0.85, 0.9, 0.95, 1.0];\n\n    // Calculate monthly progression based on current stats\n    const monthlyViews = months.map((month, index) => ({\n      month,\n      views: Math.round(currentViews * progressionFactors[index])\n    }));\n    const monthlySubscribers = months.map((month, index) => ({\n      month,\n      subscribers: Math.round(currentSubscribers * progressionFactors[index])\n    }));\n    return {\n      channelStats,\n      recentVideos,\n      monthlyViews,\n      monthlySubscribers\n    };\n  }\n}\nexport const youtubeService = new YouTubeService();","map":{"version":3,"names":["buildYouTubeUrl","YOUTUBE_ENDPOINTS","YouTubeService","constructor","config","lastApiCall","apiCallCount","MAX_DAILY_CALLS","MIN_CALL_INTERVAL","cachedData","lastCached","savedConfig","localStorage","getItem","console","log","parsed","JSON","parse","channelId","apiKey","channelName","channelUrl","loadApiCallTracking","loadCachedData","today","Date","toDateString","savedTracking","tracking","date","count","lastCall","saveApiCallTracking","setItem","stringify","savedCachedData","saveCachedData","canMakeApiCall","now","checkActualApiQuota","cachedDate","channelStats","timeSinceLastCall","url","channel","part","id","response","fetch","status","error","recordApiCall","updateConfig","newConfig","getConfig","debugCachedData","currentCachedData","cacheDemoDataAsReal","demoChannelStats","subscriberCount","videoCount","viewCount","demoVideos","title","publishedAt","likeCount","commentCount","thumbnail","duration","recentVideos","getApiCallStatus","hasValidConfig","dailyCalls","maxCalls","remainingCalls","canMakeCall","usingDemoData","reason","showCallCount","actualQuotaExceeded","isQuotaExceeded","isRateLimited","hasCachedData","actualQuotaAvailable","timeUntilNextCall","minutesUntilNext","Math","ceil","max","usingCachedData","timeUntilNext","fetchFromAPI","ok","errorText","text","Error","data","json","getChannelStats","items","length","parseInt","statistics","snippet","getRecentVideos","limit","videos","order","maxResults","toString","type","videoIds","map","item","videoId","join","thumbnails","medium","statsUrl","videoStats","statsData","statsMap","Map","forEach","set","contentDetails","stats","get","getAnalytics","Promise","all","currentSubscribers","currentViews","months","i","getFullYear","getMonth","push","toLocaleDateString","month","progressionFactors","monthlyViews","index","views","round","monthlySubscribers","subscribers","youtubeService"],"sources":["/Users/marcodamm/Desktop/Stats_SocialMedia/src/services/youtubeService.ts"],"sourcesContent":["import { buildYouTubeUrl, YOUTUBE_ENDPOINTS, YouTubeConfig } from '../config/youtube';\n\nexport interface YouTubeChannelStats {\n  subscriberCount: number;\n  videoCount: number;\n  viewCount: number;\n  channelName: string;\n  channelUrl: string;\n  channelId: string;\n}\n\nexport interface YouTubeVideo {\n  id: string;\n  title: string;\n  publishedAt: string;\n  viewCount: number;\n  likeCount: number;\n  commentCount: number;\n  thumbnail: string;\n  duration: string;\n}\n\nexport interface YouTubeAnalytics {\n  channelStats: YouTubeChannelStats;\n  recentVideos: YouTubeVideo[];\n  monthlyViews: Array<{ month: string; views: number }>;\n  monthlySubscribers: Array<{ month: string; subscribers: number }>;\n}\n\nclass YouTubeService {\n  private config: YouTubeConfig;\n  private lastApiCall: number = 0;\n  private apiCallCount: number = 0;\n  private readonly MAX_DAILY_CALLS = 4; // Maximum 4 calls per day (very conservative)\n  private readonly MIN_CALL_INTERVAL = 21600000; // 6 hours between calls (4 per day max)\n  private cachedData: {\n    channelStats?: YouTubeChannelStats;\n    recentVideos?: YouTubeVideo[];\n    lastCached: number;\n  } = { lastCached: 0 };\n\n  constructor() {\n    // Load saved configuration from localStorage\n    const savedConfig = localStorage.getItem('youtubeConfig');\n    console.log('Loading YouTube config from localStorage:', savedConfig);\n    if (savedConfig) {\n      const parsed = JSON.parse(savedConfig);\n      this.config = {\n        channelId: parsed.channelId || '',\n        apiKey: parsed.apiKey || '',\n        channelName: parsed.channelName || '',\n        channelUrl: parsed.channelUrl || '',\n      };\n      console.log('Loaded config:', this.config);\n    } else {\n      this.config = {\n        channelId: '',\n        apiKey: '',\n        channelName: '',\n        channelUrl: '',\n      };\n      console.log('No saved config, using defaults');\n    }\n\n    // Load API call tracking from localStorage\n    this.loadApiCallTracking();\n    \n    // Load cached data from localStorage\n    this.loadCachedData();\n  }\n\n  private loadApiCallTracking() {\n    const today = new Date().toDateString();\n    const savedTracking = localStorage.getItem('youtubeApiTracking');\n    \n    if (savedTracking) {\n      const tracking = JSON.parse(savedTracking);\n      if (tracking.date === today) {\n        this.apiCallCount = tracking.count || 0;\n        this.lastApiCall = tracking.lastCall || 0;\n      } else {\n        // Reset for new day\n        this.apiCallCount = 0;\n        this.lastApiCall = 0;\n      }\n    }\n  }\n\n  private saveApiCallTracking() {\n    const tracking = {\n      date: new Date().toDateString(),\n      count: this.apiCallCount,\n      lastCall: this.lastApiCall\n    };\n    localStorage.setItem('youtubeApiTracking', JSON.stringify(tracking));\n  }\n\n  private loadCachedData() {\n    const savedCachedData = localStorage.getItem('youtubeCachedData');\n    if (savedCachedData) {\n      this.cachedData = JSON.parse(savedCachedData);\n      console.log('Loaded cached data:', this.cachedData);\n    } else {\n      console.log('No cached data found in localStorage');\n    }\n  }\n\n  private saveCachedData() {\n    localStorage.setItem('youtubeCachedData', JSON.stringify(this.cachedData));\n  }\n\n  private canMakeApiCall(): boolean {\n    const now = Date.now();\n    \n    // Check if we've exceeded daily limit\n    if (this.apiCallCount >= this.MAX_DAILY_CALLS) {\n      console.log('Daily API call limit reached');\n      return false;\n    }\n    \n    // Check if enough time has passed since last call\n    if (now - this.lastApiCall < this.MIN_CALL_INTERVAL) {\n      console.log('API call rate limit: waiting for cooldown');\n      return false;\n    }\n    \n    return true;\n  }\n\n  // Check if we've actually hit the YouTube API quota (403 errors)\n  private async checkActualApiQuota(): Promise<boolean> {\n    if (!this.config.apiKey || !this.config.channelId) {\n      return true; // No config means no quota check needed\n    }\n\n    // If we have cached data from today, assume API is working\n    const today = new Date().toDateString();\n    const cachedDate = new Date(this.cachedData.lastCached).toDateString();\n    if (this.cachedData.channelStats && cachedDate === today) {\n      console.log('Using cached data from today, assuming API is available');\n      return true;\n    }\n\n    // Only check actual quota if we haven't made a call recently\n    const timeSinceLastCall = Date.now() - this.lastApiCall;\n    if (timeSinceLastCall < 300000) { // 5 minutes\n      console.log('Recent API call made, skipping quota check');\n      return true;\n    }\n\n    try {\n      const url = buildYouTubeUrl(YOUTUBE_ENDPOINTS.channel, {\n        part: 'statistics,snippet',\n        id: this.config.channelId,\n      }, this.config.apiKey);\n\n      const response = await fetch(url);\n      console.log('Quota check response status:', response.status);\n      \n      if (response.status === 403) {\n        console.log('YouTube API quota actually exceeded');\n        return false; // Quota exceeded\n      }\n      \n      return true; // API is available\n    } catch (error) {\n      console.log('Error checking API quota:', error);\n      return false; // Assume quota exceeded on error\n    }\n  }\n\n  private recordApiCall() {\n    this.apiCallCount++;\n    this.lastApiCall = Date.now();\n    this.saveApiCallTracking();\n    console.log(`API call recorded. Daily count: ${this.apiCallCount}/${this.MAX_DAILY_CALLS}`);\n  }\n\n  updateConfig(newConfig: YouTubeConfig) {\n    this.config = newConfig;\n    localStorage.setItem('youtubeConfig', JSON.stringify(newConfig));\n  }\n\n  getConfig(): YouTubeConfig {\n    return this.config;\n  }\n\n  // Debug method to check localStorage\n  debugCachedData() {\n    const savedCachedData = localStorage.getItem('youtubeCachedData');\n    const savedConfig = localStorage.getItem('youtubeConfig');\n    const savedTracking = localStorage.getItem('youtubeApiTracking');\n    \n    console.log('=== DEBUG CACHED DATA ===');\n    console.log('youtubeCachedData:', savedCachedData);\n    console.log('youtubeConfig:', savedConfig);\n    console.log('youtubeApiTracking:', savedTracking);\n    console.log('Current cachedData object:', this.cachedData);\n    console.log('========================');\n    \n    return {\n      cachedData: savedCachedData ? JSON.parse(savedCachedData) : null,\n      config: savedConfig ? JSON.parse(savedConfig) : null,\n      tracking: savedTracking ? JSON.parse(savedTracking) : null,\n      currentCachedData: this.cachedData\n    };\n  }\n\n  // Method to manually cache demo data as real data (for testing)\n  cacheDemoDataAsReal() {\n    const demoChannelStats = {\n      subscriberCount: 12400,\n      videoCount: 89,\n      viewCount: 1800000,\n      channelName: this.config.channelName || 'Maggo',\n      channelUrl: this.config.channelUrl || 'https://www.youtube.com/@maggo',\n      channelId: this.config.channelId || 'UCZggs3Q7sC5QQZGeQYJd5pA',\n    };\n\n    const demoVideos = [\n      {\n        id: 'demo-video-1',\n        title: 'Sample Video Title 1',\n        publishedAt: '2024-01-15T10:00:00Z',\n        viewCount: 15000,\n        likeCount: 1200,\n        commentCount: 89,\n        thumbnail: 'https://via.placeholder.com/320x180',\n        duration: 'PT10M30S',\n      },\n      {\n        id: 'demo-video-2',\n        title: 'Sample Video Title 2',\n        publishedAt: '2024-01-10T14:30:00Z',\n        viewCount: 22000,\n        likeCount: 1800,\n        commentCount: 156,\n        thumbnail: 'https://via.placeholder.com/320x180',\n        duration: 'PT15M45S',\n      },\n    ];\n\n    this.cachedData.channelStats = demoChannelStats;\n    this.cachedData.recentVideos = demoVideos;\n    this.cachedData.lastCached = Date.now();\n    this.saveCachedData();\n    \n    console.log('Manually cached demo data as real data:', this.cachedData);\n    return this.cachedData;\n  }\n\n  async getApiCallStatus() {\n    // Check if we have valid config\n    const hasValidConfig = this.config.apiKey && this.config.channelId;\n    \n    // If no valid config, show as unlimited since we're using demo data\n    if (!hasValidConfig) {\n      return {\n        dailyCalls: 0,\n        maxCalls: this.MAX_DAILY_CALLS,\n        remainingCalls: this.MAX_DAILY_CALLS,\n        lastCall: this.lastApiCall,\n        canMakeCall: true,\n        usingDemoData: true,\n        reason: 'No API configuration',\n        showCallCount: false,\n        actualQuotaExceeded: false\n      };\n    }\n\n    // Check if we're actually hitting quota limits\n    const isQuotaExceeded = this.apiCallCount >= this.MAX_DAILY_CALLS;\n    const isRateLimited = Date.now() - this.lastApiCall < this.MIN_CALL_INTERVAL;\n    const hasCachedData = this.cachedData.channelStats && this.cachedData.recentVideos;\n    \n    // Check actual YouTube API quota status\n    const actualQuotaAvailable = await this.checkActualApiQuota();\n    const actualQuotaExceeded = !actualQuotaAvailable;\n    \n    // Calculate time until next available call\n    const timeUntilNextCall = this.lastApiCall + this.MIN_CALL_INTERVAL - Date.now();\n    const minutesUntilNext = Math.ceil(timeUntilNextCall / 60000);\n    \n    // Determine the actual status\n    let canMakeCall = true;\n    let showCallCount = true;\n    \n          if (actualQuotaExceeded) {\n        canMakeCall = false;\n        showCallCount = false;\n      } else if (isQuotaExceeded) {\n        canMakeCall = false;\n        showCallCount = false;\n      } else if (isRateLimited) {\n        canMakeCall = false;\n        showCallCount = false;\n      }\n\n      return {\n        dailyCalls: this.apiCallCount,\n        maxCalls: this.MAX_DAILY_CALLS,\n        remainingCalls: Math.max(0, this.MAX_DAILY_CALLS - this.apiCallCount),\n        lastCall: this.lastApiCall,\n        canMakeCall,\n        usingCachedData: (!canMakeCall) && hasCachedData,\n        usingDemoData: (!canMakeCall) && !hasCachedData,\n        reason: isQuotaExceeded ? 'Daily quota exceeded - wait 24 hours (4 calls max)' : \n                isRateLimited ? `Rate limited - wait ${minutesUntilNext} minutes (6h cooldown)` : 'Ready',\n        showCallCount,\n        timeUntilNext: timeUntilNextCall,\n        actualQuotaExceeded\n      };\n  }\n\n  private async fetchFromAPI(url: string): Promise<any> {\n    console.log('Making API call to:', url);\n    const response = await fetch(url);\n    console.log('API response status:', response.status);\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('API Error response:', errorText);\n      \n      if (response.status === 403) {\n        throw new Error('API quota exceeded or invalid API key');\n      } else if (response.status === 400) {\n        throw new Error('Invalid request - check channel ID');\n      } else {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n    }\n    \n    const data = await response.json();\n    console.log('API response data:', data);\n    return data;\n  }\n\n  async getChannelStats(): Promise<YouTubeChannelStats> {\n    console.log('getChannelStats called with config:', this.config);\n    console.log('Current cached data:', this.cachedData);\n    \n    // If no API key or channel ID, return mock data\n    if (!this.config.apiKey || !this.config.channelId) {\n      console.log('No API key or channel ID, returning mock data');\n      return {\n        subscriberCount: 12400,\n        videoCount: 89,\n        viewCount: 1800000,\n        channelName: this.config.channelName || 'Demo Channel',\n        channelUrl: this.config.channelUrl || 'https://www.youtube.com/@demo',\n        channelId: this.config.channelId || 'demo-channel-id',\n      };\n    }\n\n    // Check if we have cached data from today first\n    const today = new Date().toDateString();\n    const cachedDate = this.cachedData.lastCached ? new Date(this.cachedData.lastCached).toDateString() : null;\n    console.log('Today:', today, 'Cached date:', cachedDate);\n    \n    if (this.cachedData.channelStats && cachedDate === today) {\n      console.log('Returning cached channel stats from today');\n      return this.cachedData.channelStats;\n    }\n\n    // Check if we can make API call\n    if (!this.canMakeApiCall()) {\n      console.log('API call limit reached, checking cached data');\n      \n      // Return cached data if available (even from previous days)\n      if (this.cachedData.channelStats) {\n        console.log('Returning cached channel stats from previous days');\n        return this.cachedData.channelStats;\n      }\n      \n      // Fall back to mock data if no cache\n      console.log('No cached data, returning mock data');\n      return {\n        subscriberCount: 12400,\n        videoCount: 89,\n        viewCount: 1800000,\n        channelName: this.config.channelName || 'Demo Channel',\n        channelUrl: this.config.channelUrl || 'https://www.youtube.com/@demo',\n        channelId: this.config.channelId || 'demo-channel-id',\n      };\n    }\n\n    // Try to make API call and cache the result\n    try {\n      const url = buildYouTubeUrl(YOUTUBE_ENDPOINTS.channel, {\n        part: 'statistics,snippet',\n        id: this.config.channelId,\n      }, this.config.apiKey);\n\n      const data = await this.fetchFromAPI(url);\n      this.recordApiCall();\n      \n      if (data.items && data.items.length > 0) {\n        const channel = data.items[0];\n        const channelStats = {\n          subscriberCount: parseInt(channel.statistics.subscriberCount || '0'),\n          videoCount: parseInt(channel.statistics.videoCount || '0'),\n          viewCount: parseInt(channel.statistics.viewCount || '0'),\n          channelName: channel.snippet.title,\n          channelUrl: `https://www.youtube.com/channel/${channel.id}`,\n          channelId: channel.id,\n        };\n        \n        // Cache the successful API response\n        this.cachedData.channelStats = channelStats;\n        this.cachedData.lastCached = Date.now();\n        this.saveCachedData();\n        console.log('Successfully cached channel stats:', channelStats);\n        \n        return channelStats;\n      }\n\n      throw new Error('Channel not found');\n    } catch (error) {\n      console.error('Error in getChannelStats:', error);\n      \n      // If we have any cached data, return it even if it's old\n      if (this.cachedData.channelStats) {\n        console.log('API failed, returning cached data');\n        return this.cachedData.channelStats;\n      }\n      \n      // Return mock data if API fails and no cache exists\n      console.log('API failed and no cache, returning mock data');\n      return {\n        subscriberCount: 12400,\n        videoCount: 89,\n        viewCount: 1800000,\n        channelName: this.config.channelName || 'Demo Channel',\n        channelUrl: this.config.channelUrl || 'https://www.youtube.com/@demo',\n        channelId: this.config.channelId || 'demo-channel-id',\n      };\n    }\n  }\n\n  async getRecentVideos(limit: number = 10): Promise<YouTubeVideo[]> {\n    // If no API key or channel ID, return mock data\n    if (!this.config.apiKey || !this.config.channelId) {\n      return [\n        {\n          id: 'mock-video-1',\n          title: 'Sample Video Title 1',\n          publishedAt: '2024-01-15T10:00:00Z',\n          viewCount: 15000,\n          likeCount: 1200,\n          commentCount: 89,\n          thumbnail: 'https://via.placeholder.com/320x180',\n          duration: 'PT10M30S',\n        },\n        {\n          id: 'mock-video-2',\n          title: 'Sample Video Title 2',\n          publishedAt: '2024-01-10T14:30:00Z',\n          viewCount: 22000,\n          likeCount: 1800,\n          commentCount: 156,\n          thumbnail: 'https://via.placeholder.com/320x180',\n          duration: 'PT15M45S',\n        },\n      ];\n    }\n\n    // Check if we have cached data from today first\n    const today = new Date().toDateString();\n    const cachedDate = new Date(this.cachedData.lastCached).toDateString();\n    if (this.cachedData.recentVideos && cachedDate === today) {\n      console.log('Returning cached videos from today');\n      return this.cachedData.recentVideos;\n    }\n\n    // Check if we can make API call\n    if (!this.canMakeApiCall()) {\n      console.log('API call limit reached, checking cached videos');\n      \n      // Return cached data if available (even from previous days)\n      if (this.cachedData.recentVideos) {\n        console.log('Returning cached videos');\n        return this.cachedData.recentVideos;\n      }\n      \n      // Fall back to mock data if no cache\n      console.log('No cached videos, returning mock data');\n      return [\n        {\n          id: 'mock-video-1',\n          title: 'Sample Video Title 1',\n          publishedAt: '2024-01-15T10:00:00Z',\n          viewCount: 15000,\n          likeCount: 1200,\n          commentCount: 89,\n          thumbnail: 'https://via.placeholder.com/320x180',\n          duration: 'PT10M30S',\n        },\n        {\n          id: 'mock-video-2',\n          title: 'Sample Video Title 2',\n          publishedAt: '2024-01-10T14:30:00Z',\n          viewCount: 22000,\n          likeCount: 1800,\n          commentCount: 156,\n          thumbnail: 'https://via.placeholder.com/320x180',\n          duration: 'PT15M45S',\n        },\n      ];\n    }\n\n    try {\n      // Make real API call\n      const url = buildYouTubeUrl(YOUTUBE_ENDPOINTS.videos, {\n        part: 'snippet',\n        channelId: this.config.channelId,\n        order: 'date',\n        maxResults: limit.toString(),\n        type: 'video',\n      }, this.config.apiKey);\n\n      const data = await this.fetchFromAPI(url);\n      this.recordApiCall();\n      \n      if (data.items) {\n        const videoIds = data.items.map((item: any) => item.id.videoId).join(',');\n        \n        // Check if we can make another API call for video stats\n        if (!this.canMakeApiCall()) {\n          console.log('API call limit reached, returning videos without detailed stats');\n          return data.items.map((item: any) => ({\n            id: item.id.videoId,\n            title: item.snippet.title,\n            publishedAt: item.snippet.publishedAt,\n            viewCount: 0,\n            likeCount: 0,\n            commentCount: 0,\n            thumbnail: item.snippet.thumbnails.medium.url,\n            duration: 'PT0S',\n          }));\n        }\n        \n        // Get detailed video statistics\n        const statsUrl = buildYouTubeUrl(YOUTUBE_ENDPOINTS.videoStats, {\n          part: 'statistics,contentDetails',\n          id: videoIds,\n        }, this.config.apiKey);\n\n        const statsData = await this.fetchFromAPI(statsUrl);\n        this.recordApiCall();\n        const statsMap = new Map();\n        \n        if (statsData.items) {\n          statsData.items.forEach((item: any) => {\n            statsMap.set(item.id, {\n              viewCount: parseInt(item.statistics.viewCount || '0'),\n              likeCount: parseInt(item.statistics.likeCount || '0'),\n              commentCount: parseInt(item.statistics.commentCount || '0'),\n              duration: item.contentDetails.duration,\n            });\n          });\n        }\n\n        const videos = data.items.map((item: any) => {\n          const stats = statsMap.get(item.id.videoId) || {\n            viewCount: 0,\n            likeCount: 0,\n            commentCount: 0,\n            duration: 'PT0S',\n          };\n\n          return {\n            id: item.id.videoId,\n            title: item.snippet.title,\n            publishedAt: item.snippet.publishedAt,\n            viewCount: stats.viewCount,\n            likeCount: stats.likeCount,\n            commentCount: stats.commentCount,\n            thumbnail: item.snippet.thumbnails.medium.url,\n            duration: stats.duration,\n          };\n        });\n        \n        // Cache the successful API response\n        this.cachedData.recentVideos = videos;\n        this.cachedData.lastCached = Date.now();\n        this.saveCachedData();\n        \n        return videos;\n      }\n\n      return [];\n    } catch (error) {\n      console.error('Error in getRecentVideos:', error);\n      \n      // Return mock data if API fails\n      return [\n        {\n          id: 'mock-video-1',\n          title: 'Sample Video Title 1',\n          publishedAt: '2024-01-15T10:00:00Z',\n          viewCount: 15000,\n          likeCount: 1200,\n          commentCount: 89,\n          thumbnail: 'https://via.placeholder.com/320x180',\n          duration: 'PT10M30S',\n        },\n        {\n          id: 'mock-video-2',\n          title: 'Sample Video Title 2',\n          publishedAt: '2024-01-10T14:30:00Z',\n          viewCount: 22000,\n          likeCount: 1800,\n          commentCount: 156,\n          thumbnail: 'https://via.placeholder.com/320x180',\n          duration: 'PT15M45S',\n        },\n      ];\n    }\n  }\n\n  async getAnalytics(): Promise<YouTubeAnalytics> {\n    const [channelStats, recentVideos] = await Promise.all([\n      this.getChannelStats(),\n      this.getRecentVideos(),\n    ]);\n\n    // Generate monthly data based on actual channel stats\n    const currentSubscribers = channelStats.subscriberCount;\n    const currentViews = channelStats.viewCount;\n    \n    // Get current date and generate last 6 months\n    const now = new Date();\n    const months = [];\n    for (let i = 5; i >= 0; i--) {\n      const date = new Date(now.getFullYear(), now.getMonth() - i, 1);\n      months.push(date.toLocaleDateString('en-US', { month: 'short' }));\n    }\n    \n    // Calculate progression factors for realistic growth\n    const progressionFactors = [0.7, 0.8, 0.85, 0.9, 0.95, 1.0];\n    \n    // Calculate monthly progression based on current stats\n    const monthlyViews = months.map((month, index) => ({\n      month,\n      views: Math.round(currentViews * progressionFactors[index])\n    }));\n\n    const monthlySubscribers = months.map((month, index) => ({\n      month,\n      subscribers: Math.round(currentSubscribers * progressionFactors[index])\n    }));\n\n    return {\n      channelStats,\n      recentVideos,\n      monthlyViews,\n      monthlySubscribers,\n    };\n  }\n}\n\nexport const youtubeService = new YouTubeService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}