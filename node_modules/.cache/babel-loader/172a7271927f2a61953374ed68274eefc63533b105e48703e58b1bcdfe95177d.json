{"ast":null,"code":"import { youtubeService } from './youtubeService';\nclass DataCollectionService {\n  constructor() {\n    this.STORAGE_KEY = 'youtube_historical_data';\n    this.DAILY_COLLECTION_KEY = 'youtube_daily_collection';\n  }\n  // Check if we should collect data today\n  shouldCollectToday() {\n    const lastCollection = localStorage.getItem(this.DAILY_COLLECTION_KEY);\n    console.log('DataCollectionService: Checking if should collect today');\n    console.log('DataCollectionService: Last collection date:', lastCollection);\n    if (!lastCollection) {\n      console.log('DataCollectionService: No last collection found, should collect today');\n      return true;\n    }\n    const lastDate = new Date(lastCollection);\n    const today = new Date();\n\n    // Use local date strings for comparison\n    const lastDateString = lastDate.toLocaleDateString('en-CA');\n    const todayDateString = today.toLocaleDateString('en-CA');\n    console.log('DataCollectionService: Last collection date object:', lastDate);\n    console.log('DataCollectionService: Today date object:', today);\n    console.log('DataCollectionService: Date comparison:', {\n      lastDateString,\n      todayDateString,\n      lastDate: lastDate.getDate(),\n      todayDate: today.getDate(),\n      lastMonth: lastDate.getMonth(),\n      todayMonth: today.getMonth(),\n      lastYear: lastDate.getFullYear(),\n      todayYear: today.getFullYear()\n    });\n\n    // Check if it's a different day using local date strings\n    const shouldCollect = lastDateString !== todayDateString;\n    console.log('DataCollectionService: Should collect today:', shouldCollect);\n    return shouldCollect;\n  }\n\n  // Collect and save today's data\n  async collectDailyData() {\n    console.log('DataCollectionService: Starting daily data collection');\n\n    // Check if YouTube service is configured\n    const youtubeConfig = youtubeService.getConfig();\n    console.log('DataCollectionService: YouTube config:', youtubeConfig);\n    if (!youtubeConfig || !youtubeConfig.apiKey || !youtubeConfig.channelId) {\n      console.error('DataCollectionService: YouTube not properly configured');\n      throw new Error('YouTube service not properly configured. Please set up your API key and channel ID first.');\n    }\n    try {\n      console.log('DataCollectionService: Fetching channel stats from YouTube service');\n      const channelStats = await youtubeService.getChannelStats();\n      console.log('DataCollectionService: Received channel stats:', channelStats);\n      if (!channelStats) {\n        throw new Error('Failed to fetch channel stats from YouTube service');\n      }\n      const todayStats = {\n        date: new Date().toLocaleDateString('en-CA'),\n        // YYYY-MM-DD format in local timezone\n        subscriberCount: channelStats.subscriberCount,\n        viewCount: channelStats.viewCount,\n        videoCount: channelStats.videoCount,\n        channelName: channelStats.channelName\n      };\n      console.log('DataCollectionService: Created today stats:', todayStats);\n\n      // Get existing historical data\n      const historicalData = this.getHistoricalData();\n      console.log('DataCollectionService: Current historical data:', historicalData);\n\n      // Add today's data if it doesn't exist\n      const existingIndex = historicalData.dailyStats.findIndex(stat => stat.date === todayStats.date);\n      console.log('DataCollectionService: Existing index for today:', existingIndex);\n      if (existingIndex === -1) {\n        console.log('DataCollectionService: Adding today\\'s data to historical data');\n        historicalData.dailyStats.push(todayStats);\n        historicalData.lastUpdated = new Date().toISOString();\n\n        // Save updated data\n        console.log('DataCollectionService: Saving to localStorage...');\n        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(historicalData));\n        localStorage.setItem(this.DAILY_COLLECTION_KEY, new Date().toISOString());\n        console.log('DataCollectionService: Daily data collected and saved:', todayStats);\n        console.log('DataCollectionService: Updated historical data:', historicalData);\n        console.log('DataCollectionService: localStorage keys saved:', {\n          STORAGE_KEY: this.STORAGE_KEY,\n          DAILY_COLLECTION_KEY: this.DAILY_COLLECTION_KEY\n        });\n      } else {\n        console.log('DataCollectionService: Today\\'s data already exists, skipping');\n      }\n    } catch (error) {\n      console.error('DataCollectionService: Error collecting daily data:', error);\n      console.error('DataCollectionService: Error details:', {\n        message: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined\n      });\n      throw error; // Re-throw to let the UI handle the error\n    }\n  }\n\n  // Get historical data from localStorage\n  getHistoricalData() {\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (stored) {\n      return JSON.parse(stored);\n    }\n    return {\n      dailyStats: [],\n      lastUpdated: new Date().toISOString()\n    };\n  }\n\n  // Get data for specific time periods\n  getDataForPeriod(days) {\n    const historicalData = this.getHistoricalData();\n    const today = new Date();\n    const cutoffDate = new Date(today.getTime() - days * 24 * 60 * 60 * 1000);\n    return historicalData.dailyStats.filter(stat => {\n      const statDate = new Date(stat.date);\n      return statDate >= cutoffDate;\n    }).sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());\n  }\n\n  // Get monthly aggregated data\n  getMonthlyData(months) {\n    const historicalData = this.getHistoricalData();\n    const today = new Date();\n    const cutoffDate = new Date(today.getFullYear(), today.getMonth() - months, 1);\n    const monthlyData = new Map();\n    historicalData.dailyStats.forEach(stat => {\n      const statDate = new Date(stat.date);\n      if (statDate >= cutoffDate) {\n        const monthKey = statDate.toLocaleDateString('en-US', {\n          year: 'numeric',\n          month: 'short'\n        });\n        if (!monthlyData.has(monthKey)) {\n          monthlyData.set(monthKey, {\n            subscribers: 0,\n            views: 0,\n            count: 0\n          });\n        }\n        const monthData = monthlyData.get(monthKey);\n        monthData.subscribers += stat.subscriberCount;\n        monthData.views += stat.viewCount;\n        monthData.count += 1;\n      }\n    });\n\n    // Calculate averages for each month\n    return Array.from(monthlyData.entries()).map(([month, data]) => ({\n      month,\n      subscribers: Math.round(data.subscribers / data.count),\n      views: Math.round(data.views / data.count)\n    })).sort((a, b) => new Date(a.month).getTime() - new Date(b.month).getTime());\n  }\n\n  // Initialize daily collection if needed\n  async initializeDailyCollection() {\n    if (this.shouldCollectToday()) {\n      await this.collectDailyData();\n    }\n  }\n\n  // Clear historical data (for testing)\n  clearHistoricalData() {\n    localStorage.removeItem(this.STORAGE_KEY);\n    localStorage.removeItem(this.DAILY_COLLECTION_KEY);\n  }\n}\nexport const dataCollectionService = new DataCollectionService();","map":{"version":3,"names":["youtubeService","DataCollectionService","constructor","STORAGE_KEY","DAILY_COLLECTION_KEY","shouldCollectToday","lastCollection","localStorage","getItem","console","log","lastDate","Date","today","lastDateString","toLocaleDateString","todayDateString","getDate","todayDate","lastMonth","getMonth","todayMonth","lastYear","getFullYear","todayYear","shouldCollect","collectDailyData","youtubeConfig","getConfig","apiKey","channelId","error","Error","channelStats","getChannelStats","todayStats","date","subscriberCount","viewCount","videoCount","channelName","historicalData","getHistoricalData","existingIndex","dailyStats","findIndex","stat","push","lastUpdated","toISOString","setItem","JSON","stringify","message","String","stack","undefined","stored","parse","getDataForPeriod","days","cutoffDate","getTime","filter","statDate","sort","a","b","getMonthlyData","months","monthlyData","Map","forEach","monthKey","year","month","has","set","subscribers","views","count","monthData","get","Array","from","entries","map","data","Math","round","initializeDailyCollection","clearHistoricalData","removeItem","dataCollectionService"],"sources":["/Users/marcodamm/Desktop/Stats_SocialMedia/src/services/dataCollectionService.ts"],"sourcesContent":["import { youtubeService } from './youtubeService';\n\nexport interface DailyStats {\n  date: string;\n  subscriberCount: number;\n  viewCount: number;\n  videoCount: number;\n  channelName: string;\n}\n\nexport interface HistoricalData {\n  dailyStats: DailyStats[];\n  lastUpdated: string;\n}\n\nclass DataCollectionService {\n  private readonly STORAGE_KEY = 'youtube_historical_data';\n  private readonly DAILY_COLLECTION_KEY = 'youtube_daily_collection';\n\n  // Check if we should collect data today\n  shouldCollectToday(): boolean {\n    const lastCollection = localStorage.getItem(this.DAILY_COLLECTION_KEY);\n    console.log('DataCollectionService: Checking if should collect today');\n    console.log('DataCollectionService: Last collection date:', lastCollection);\n    \n    if (!lastCollection) {\n      console.log('DataCollectionService: No last collection found, should collect today');\n      return true;\n    }\n\n    const lastDate = new Date(lastCollection);\n    const today = new Date();\n    \n    // Use local date strings for comparison\n    const lastDateString = lastDate.toLocaleDateString('en-CA');\n    const todayDateString = today.toLocaleDateString('en-CA');\n    \n    console.log('DataCollectionService: Last collection date object:', lastDate);\n    console.log('DataCollectionService: Today date object:', today);\n    console.log('DataCollectionService: Date comparison:', {\n      lastDateString,\n      todayDateString,\n      lastDate: lastDate.getDate(),\n      todayDate: today.getDate(),\n      lastMonth: lastDate.getMonth(),\n      todayMonth: today.getMonth(),\n      lastYear: lastDate.getFullYear(),\n      todayYear: today.getFullYear()\n    });\n    \n    // Check if it's a different day using local date strings\n    const shouldCollect = lastDateString !== todayDateString;\n           \n    console.log('DataCollectionService: Should collect today:', shouldCollect);\n    return shouldCollect;\n  }\n\n  // Collect and save today's data\n  async collectDailyData(): Promise<void> {\n    console.log('DataCollectionService: Starting daily data collection');\n    \n    // Check if YouTube service is configured\n    const youtubeConfig = youtubeService.getConfig();\n    console.log('DataCollectionService: YouTube config:', youtubeConfig);\n    \n    if (!youtubeConfig || !youtubeConfig.apiKey || !youtubeConfig.channelId) {\n      console.error('DataCollectionService: YouTube not properly configured');\n      throw new Error('YouTube service not properly configured. Please set up your API key and channel ID first.');\n    }\n    \n    try {\n      console.log('DataCollectionService: Fetching channel stats from YouTube service');\n      const channelStats = await youtubeService.getChannelStats();\n      console.log('DataCollectionService: Received channel stats:', channelStats);\n      \n      if (!channelStats) {\n        throw new Error('Failed to fetch channel stats from YouTube service');\n      }\n      \n      const todayStats: DailyStats = {\n        date: new Date().toLocaleDateString('en-CA'), // YYYY-MM-DD format in local timezone\n        subscriberCount: channelStats.subscriberCount,\n        viewCount: channelStats.viewCount,\n        videoCount: channelStats.videoCount,\n        channelName: channelStats.channelName,\n      };\n      \n      console.log('DataCollectionService: Created today stats:', todayStats);\n\n      // Get existing historical data\n      const historicalData = this.getHistoricalData();\n      console.log('DataCollectionService: Current historical data:', historicalData);\n      \n      // Add today's data if it doesn't exist\n      const existingIndex = historicalData.dailyStats.findIndex(\n        stat => stat.date === todayStats.date\n      );\n      \n      console.log('DataCollectionService: Existing index for today:', existingIndex);\n      \n      if (existingIndex === -1) {\n        console.log('DataCollectionService: Adding today\\'s data to historical data');\n        historicalData.dailyStats.push(todayStats);\n        historicalData.lastUpdated = new Date().toISOString();\n        \n        // Save updated data\n        console.log('DataCollectionService: Saving to localStorage...');\n        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(historicalData));\n        localStorage.setItem(this.DAILY_COLLECTION_KEY, new Date().toISOString());\n        \n        console.log('DataCollectionService: Daily data collected and saved:', todayStats);\n        console.log('DataCollectionService: Updated historical data:', historicalData);\n        console.log('DataCollectionService: localStorage keys saved:', {\n          STORAGE_KEY: this.STORAGE_KEY,\n          DAILY_COLLECTION_KEY: this.DAILY_COLLECTION_KEY\n        });\n      } else {\n        console.log('DataCollectionService: Today\\'s data already exists, skipping');\n      }\n    } catch (error) {\n      console.error('DataCollectionService: Error collecting daily data:', error);\n      console.error('DataCollectionService: Error details:', {\n        message: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined\n      });\n      throw error; // Re-throw to let the UI handle the error\n    }\n  }\n\n  // Get historical data from localStorage\n  getHistoricalData(): HistoricalData {\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (stored) {\n      return JSON.parse(stored);\n    }\n    \n    return {\n      dailyStats: [],\n      lastUpdated: new Date().toISOString(),\n    };\n  }\n\n  // Get data for specific time periods\n  getDataForPeriod(days: number): DailyStats[] {\n    const historicalData = this.getHistoricalData();\n    const today = new Date();\n    const cutoffDate = new Date(today.getTime() - (days * 24 * 60 * 60 * 1000));\n    \n    return historicalData.dailyStats.filter(stat => {\n      const statDate = new Date(stat.date);\n      return statDate >= cutoffDate;\n    }).sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());\n  }\n\n  // Get monthly aggregated data\n  getMonthlyData(months: number): Array<{ month: string; subscribers: number; views: number }> {\n    const historicalData = this.getHistoricalData();\n    const today = new Date();\n    const cutoffDate = new Date(today.getFullYear(), today.getMonth() - months, 1);\n    \n    const monthlyData = new Map<string, { subscribers: number; views: number; count: number }>();\n    \n    historicalData.dailyStats.forEach(stat => {\n      const statDate = new Date(stat.date);\n      if (statDate >= cutoffDate) {\n        const monthKey = statDate.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });\n        \n        if (!monthlyData.has(monthKey)) {\n          monthlyData.set(monthKey, { subscribers: 0, views: 0, count: 0 });\n        }\n        \n        const monthData = monthlyData.get(monthKey)!;\n        monthData.subscribers += stat.subscriberCount;\n        monthData.views += stat.viewCount;\n        monthData.count += 1;\n      }\n    });\n    \n    // Calculate averages for each month\n    return Array.from(monthlyData.entries()).map(([month, data]) => ({\n      month,\n      subscribers: Math.round(data.subscribers / data.count),\n      views: Math.round(data.views / data.count),\n    })).sort((a, b) => new Date(a.month).getTime() - new Date(b.month).getTime());\n  }\n\n  // Initialize daily collection if needed\n  async initializeDailyCollection(): Promise<void> {\n    if (this.shouldCollectToday()) {\n      await this.collectDailyData();\n    }\n  }\n\n  // Clear historical data (for testing)\n  clearHistoricalData(): void {\n    localStorage.removeItem(this.STORAGE_KEY);\n    localStorage.removeItem(this.DAILY_COLLECTION_KEY);\n  }\n}\n\nexport const dataCollectionService = new DataCollectionService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}