{"ast":null,"code":"import{youtubeService}from'./youtubeService';class DataCollectionService{constructor(){this.STORAGE_KEY='youtube_historical_data';this.DAILY_COLLECTION_KEY='youtube_daily_collection';}// Check if we should collect data today\nshouldCollectToday(){const lastCollection=localStorage.getItem(this.DAILY_COLLECTION_KEY);if(!lastCollection)return true;const lastDate=new Date(lastCollection);const today=new Date();// Check if it's a different day\nreturn lastDate.getDate()!==today.getDate()||lastDate.getMonth()!==today.getMonth()||lastDate.getFullYear()!==today.getFullYear();}// Collect and save today's data\nasync collectDailyData(){try{const channelStats=await youtubeService.getChannelStats();const todayStats={date:new Date().toISOString().split('T')[0],// YYYY-MM-DD format\nsubscriberCount:channelStats.subscriberCount,viewCount:channelStats.viewCount,videoCount:channelStats.videoCount,channelName:channelStats.channelName};// Get existing historical data\nconst historicalData=this.getHistoricalData();// Add today's data if it doesn't exist\nconst existingIndex=historicalData.dailyStats.findIndex(stat=>stat.date===todayStats.date);if(existingIndex===-1){historicalData.dailyStats.push(todayStats);historicalData.lastUpdated=new Date().toISOString();// Save updated data\nlocalStorage.setItem(this.STORAGE_KEY,JSON.stringify(historicalData));localStorage.setItem(this.DAILY_COLLECTION_KEY,new Date().toISOString());console.log('Daily data collected:',todayStats);}}catch(error){console.error('Error collecting daily data:',error);}}// Get historical data from localStorage\ngetHistoricalData(){const stored=localStorage.getItem(this.STORAGE_KEY);if(stored){return JSON.parse(stored);}return{dailyStats:[],lastUpdated:new Date().toISOString()};}// Get data for specific time periods\ngetDataForPeriod(days){const historicalData=this.getHistoricalData();const today=new Date();const cutoffDate=new Date(today.getTime()-days*24*60*60*1000);return historicalData.dailyStats.filter(stat=>{const statDate=new Date(stat.date);return statDate>=cutoffDate;}).sort((a,b)=>new Date(a.date).getTime()-new Date(b.date).getTime());}// Get monthly aggregated data\ngetMonthlyData(months){const historicalData=this.getHistoricalData();const today=new Date();const cutoffDate=new Date(today.getFullYear(),today.getMonth()-months,1);const monthlyData=new Map();historicalData.dailyStats.forEach(stat=>{const statDate=new Date(stat.date);if(statDate>=cutoffDate){const monthKey=statDate.toLocaleDateString('en-US',{year:'numeric',month:'short'});if(!monthlyData.has(monthKey)){monthlyData.set(monthKey,{subscribers:0,views:0,count:0});}const monthData=monthlyData.get(monthKey);monthData.subscribers+=stat.subscriberCount;monthData.views+=stat.viewCount;monthData.count+=1;}});// Calculate averages for each month\nreturn Array.from(monthlyData.entries()).map(_ref=>{let[month,data]=_ref;return{month,subscribers:Math.round(data.subscribers/data.count),views:Math.round(data.views/data.count)};}).sort((a,b)=>new Date(a.month).getTime()-new Date(b.month).getTime());}// Initialize daily collection if needed\nasync initializeDailyCollection(){if(this.shouldCollectToday()){await this.collectDailyData();}}// Clear historical data (for testing)\nclearHistoricalData(){localStorage.removeItem(this.STORAGE_KEY);localStorage.removeItem(this.DAILY_COLLECTION_KEY);}}export const dataCollectionService=new DataCollectionService();","map":{"version":3,"names":["youtubeService","DataCollectionService","constructor","STORAGE_KEY","DAILY_COLLECTION_KEY","shouldCollectToday","lastCollection","localStorage","getItem","lastDate","Date","today","getDate","getMonth","getFullYear","collectDailyData","channelStats","getChannelStats","todayStats","date","toISOString","split","subscriberCount","viewCount","videoCount","channelName","historicalData","getHistoricalData","existingIndex","dailyStats","findIndex","stat","push","lastUpdated","setItem","JSON","stringify","console","log","error","stored","parse","getDataForPeriod","days","cutoffDate","getTime","filter","statDate","sort","a","b","getMonthlyData","months","monthlyData","Map","forEach","monthKey","toLocaleDateString","year","month","has","set","subscribers","views","count","monthData","get","Array","from","entries","map","_ref","data","Math","round","initializeDailyCollection","clearHistoricalData","removeItem","dataCollectionService"],"sources":["/Users/marcodamm/Desktop/Stats_SocialMedia/src/services/dataCollectionService.ts"],"sourcesContent":["import { youtubeService } from './youtubeService';\n\nexport interface DailyStats {\n  date: string;\n  subscriberCount: number;\n  viewCount: number;\n  videoCount: number;\n  channelName: string;\n}\n\nexport interface HistoricalData {\n  dailyStats: DailyStats[];\n  lastUpdated: string;\n}\n\nclass DataCollectionService {\n  private readonly STORAGE_KEY = 'youtube_historical_data';\n  private readonly DAILY_COLLECTION_KEY = 'youtube_daily_collection';\n\n  // Check if we should collect data today\n  shouldCollectToday(): boolean {\n    const lastCollection = localStorage.getItem(this.DAILY_COLLECTION_KEY);\n    if (!lastCollection) return true;\n\n    const lastDate = new Date(lastCollection);\n    const today = new Date();\n    \n    // Check if it's a different day\n    return lastDate.getDate() !== today.getDate() || \n           lastDate.getMonth() !== today.getMonth() || \n           lastDate.getFullYear() !== today.getFullYear();\n  }\n\n  // Collect and save today's data\n  async collectDailyData(): Promise<void> {\n    try {\n      const channelStats = await youtubeService.getChannelStats();\n      \n      const todayStats: DailyStats = {\n        date: new Date().toISOString().split('T')[0], // YYYY-MM-DD format\n        subscriberCount: channelStats.subscriberCount,\n        viewCount: channelStats.viewCount,\n        videoCount: channelStats.videoCount,\n        channelName: channelStats.channelName,\n      };\n\n      // Get existing historical data\n      const historicalData = this.getHistoricalData();\n      \n      // Add today's data if it doesn't exist\n      const existingIndex = historicalData.dailyStats.findIndex(\n        stat => stat.date === todayStats.date\n      );\n      \n      if (existingIndex === -1) {\n        historicalData.dailyStats.push(todayStats);\n        historicalData.lastUpdated = new Date().toISOString();\n        \n        // Save updated data\n        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(historicalData));\n        localStorage.setItem(this.DAILY_COLLECTION_KEY, new Date().toISOString());\n        \n        console.log('Daily data collected:', todayStats);\n      }\n    } catch (error) {\n      console.error('Error collecting daily data:', error);\n    }\n  }\n\n  // Get historical data from localStorage\n  getHistoricalData(): HistoricalData {\n    const stored = localStorage.getItem(this.STORAGE_KEY);\n    if (stored) {\n      return JSON.parse(stored);\n    }\n    \n    return {\n      dailyStats: [],\n      lastUpdated: new Date().toISOString(),\n    };\n  }\n\n  // Get data for specific time periods\n  getDataForPeriod(days: number): DailyStats[] {\n    const historicalData = this.getHistoricalData();\n    const today = new Date();\n    const cutoffDate = new Date(today.getTime() - (days * 24 * 60 * 60 * 1000));\n    \n    return historicalData.dailyStats.filter(stat => {\n      const statDate = new Date(stat.date);\n      return statDate >= cutoffDate;\n    }).sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());\n  }\n\n  // Get monthly aggregated data\n  getMonthlyData(months: number): Array<{ month: string; subscribers: number; views: number }> {\n    const historicalData = this.getHistoricalData();\n    const today = new Date();\n    const cutoffDate = new Date(today.getFullYear(), today.getMonth() - months, 1);\n    \n    const monthlyData = new Map<string, { subscribers: number; views: number; count: number }>();\n    \n    historicalData.dailyStats.forEach(stat => {\n      const statDate = new Date(stat.date);\n      if (statDate >= cutoffDate) {\n        const monthKey = statDate.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });\n        \n        if (!monthlyData.has(monthKey)) {\n          monthlyData.set(monthKey, { subscribers: 0, views: 0, count: 0 });\n        }\n        \n        const monthData = monthlyData.get(monthKey)!;\n        monthData.subscribers += stat.subscriberCount;\n        monthData.views += stat.viewCount;\n        monthData.count += 1;\n      }\n    });\n    \n    // Calculate averages for each month\n    return Array.from(monthlyData.entries()).map(([month, data]) => ({\n      month,\n      subscribers: Math.round(data.subscribers / data.count),\n      views: Math.round(data.views / data.count),\n    })).sort((a, b) => new Date(a.month).getTime() - new Date(b.month).getTime());\n  }\n\n  // Initialize daily collection if needed\n  async initializeDailyCollection(): Promise<void> {\n    if (this.shouldCollectToday()) {\n      await this.collectDailyData();\n    }\n  }\n\n  // Clear historical data (for testing)\n  clearHistoricalData(): void {\n    localStorage.removeItem(this.STORAGE_KEY);\n    localStorage.removeItem(this.DAILY_COLLECTION_KEY);\n  }\n}\n\nexport const dataCollectionService = new DataCollectionService(); "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}